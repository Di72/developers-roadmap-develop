# JavaScript

## Данные

* Какие типы данных есть в JS?
всего их 8, string, number(NaN тоже number), BigInt, boolean, null, undefined, symbols, object (arr, fn)
* Какие типы в JS изменяемые, а какие нет? const (примитивные) неизменяемы, а var/let изменяемые. исключение: const person1 = {};
person1['firstname'] = 'Mario';
console.log(person1.firstname); // expected output: "Mario"

* Что значит ссылка на переменную? При изменение пременной по ссылке меняется изменяется и оригинальная переменная. если мы меняеь объект по сылке, то мы меняем и сам объект. а вот let 2 = let 1 и мы меняем лет 2, то лет 1 сохарняется, т.к. мы меняем копию лет 1 ввиду лет 1 https://medium.com/webbdev/js-49122c7d8c26
* Что такое `NaN`? Как проверить, что переменная - `NaN`? NaN - Not a Number это специальное числовое значение, также как и Infinity, -Infinityю. NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например: если делить строку на число или приобразовывать "абсвч" в число. Проверяется с помощью метода isNaN(значение)
* Что значит создавать переменную через конструктор или через литерал?
литеральной нотации:
//создаем пустой объект
var cat = {};
//добавляем свойство:
cat.name = "Garfield";
//или метод:
cat.getName = function() {
  return cat.name;
};
// конструктор-функция:
var cat = new Object();
cat.name = "Garfield";
* Когда при обращении к свойству объекта стоит использовать точечную нотацию, а когда через строку в квадратных скобках?
квадратные пример: let key = prompt("Что вы хотите узнать о пользователе?", "name");
alert( user[key] ); // John (если ввели "name") - выводит даже то что выполняетя по ходу и свойства из двух слов. 2. через точку когда имя известно и стабильно, а через [] когда переменная
* Что произойдет, если попытаться получить несуществующее в объекте свойство? - undefined
* Что делает `hasOwnProperty`? Этот метод может использоваться для определения того, содержит ли объект указанное свойство в качестве собственного свойства объекта;
object1.hasOwnProperty('property1'));
// expected output: true

* Когда использовать `null`, а когда `undefined`? null может рассматриваться как преднамеренное отсутствие значения какого-либо объекта. undefined это когда значением просто отсуствует. Практически всегда лучше null
* Какие есть способы создания глобальных переменных? объявление переменной вне всяких функций или добавить к объявлению переменной window
* Для чего нужна директива `use strict`?  Чтобы устаревший код работал, как и раньше, по умолчанию подобные изменения не применяются. Поэтому нам нужно явно их активировать с помощью специальной директивы: "use strict".

#### Ресурсы

* [Types (Airbnb JavaScript Style Guide)](https://github.com/airbnb/javascript#types)
* [Объекты как ассоциативные массивы](https://learn.javascript.ru/object)

## Выражения

* Что такое выражения и инструкции? В чем отличия между ними? 
1. Любое выражение — это инструкция.
2. Не каждая инструкция — выражение.
if (a){} else{} и т.д. — инструкция, но не выражение, ибо ничего не выражается, но действия происходят.

* Чем отличаются `var`, `let`, `const`? Почему использование `const` может быть предпочтительнее? созданная с помощью оператора let, доступна внутри блока, в котором она была создана и в любом вложенном блоке. Говоря «блок», я имею ввиду всё что вложено между фигурными скобками {}.значение переменной, объявленной с помощью const, нельзя переназначит
* Что такое тернарный оператор? ?
* Что делает оператор `for..in`? Какие имеются особенности при использовании этого оператора с массивами? объявление переменной внутри и возможность вытаскивать значения и ключи, но не порядку (!). for...of для массива, только значения, но по порядку нахождения в массиве.
* Как безопасно проверить, что переменная существует (была объявлена), и не словить ReferenceError? if (window.someVariable != null){
  // если попали сюда, то переменная существует
} или тернарный оператор или typeof a !== 'undefined'

#### Ресурсы

* [Выражения и инструкции](https://ru.hexlet.io/courses/introduction_to_programming/lessons/expressions/theory_unit)
* [JavaScript: Выражения и инструкции](https://puzzleweb.ru/javascript/2_syntax3.php)
* [Variable Declarations](https://www.typescriptlang.org/docs/handbook/variable-declarations.html)

## Массивы

* Способы создания массивов (литерал, конструктор, фабричные методы `Array.from()` и `Array.of()`);
  литерал - [element0, element1, ..., elementN],
  через конструктор - new Array(element0, element1[, ...[, elementN]]),
  через функцию - const array2 = Array(1,2)
  Array.of(element0[, element1[, ...[, elementN]]])
  `Array.from()` Нужно оговорить, что объект, из которого создаём массив должен быть массивоподобным или итерируемым (перебираемым). Массивоподобным объектом является любой объект, содержащий числовые индексы и свойство length
* Удаление элемента из массива (какие есть способы и в чем особенности);
pop - удалит первый элемент из заданного массива
shift - удалит последний элемент из массива
splice( 1, 2)
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");

alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"

slice([start], [end]) - Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end).
delete - мутирует массив, со значением удалённого элемента undefined

* Свойство `length` у массива
  * Какое значение будет у свойства `length` массива `a` и почему: js.js:32 (11) [1, 2, 3, empty × 7, 4]
      ```javascript
      const a = [1, 2, 3];
      a[10] = 4;
      ```
    * Что будет, если переприсвоить новое значение?
    * Влияет ли на `length` удаление элемента посередине массива? Какие способы удаления элементов влияют на длину, а какие нет?
    delete arr[1]; // удалить "go" - удаляет значение, но не ключ
    arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
    splice муттирует
    slice копирует
* Как проверить, что в переменной лежит массив? 
variable.constructor === Array
* Что делают, как и когда использовать следующие методы:
  * `reduce` - reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
  * `sort` сортирует массив «на месте», а потом возвращает его. по умолчанию сортирует по Юникоду.
  * `filter` фильтрует элементы через функцию и отдаёт все значения, при прохождении которых через функцию возвращается true.
  * `map` map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
  * `forEach` вызывает func для каждого элемента. Ничего не возвращает.
  * `some` проверяет, удовлетворяет ли какой-либо(!) элемент массива условию, заданному в передаваемой функции.Буливый
  * `every` проверяет, удовлетворяют ли все(!) элементы массива условию, заданному в передаваемой функции. Булевый

#### Ресурсы

* [Массивы. MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)

## Функции

* Какие есть 4 шаблона вызова функции, которые задают контекст выполнения этой функции?
  1.Вызов метода - var obj = {
    value: 0,
    increment: function() {
        this.value+=1;
    }
};
 
obj.increment();
В «вызове метода» значение this будет ссылаться на объект, которому принадлежит функция, в нашем случае на obj, причем данная связь будет установлена после запуска функции, что носит термин позднего привязывания (late binding).
  2.Вызов функции — Function Invocation 
var value = 500; //Global variable
var obj = {
    value: 0,
    increment: function() {
        this.value++;
 
        var innerFunction = function() {
            alert(this.value);
        }
 
        innerFunction(); //Function invocation pattern
    }
}
obj.increment(); //Method invocation pattern = 500
Используя данный паттерн, this привязывается к global object. Это, несомненно, является ошибкой языка.
   3.Вызов конструктора — Constructor Invocation
  var Cheese = function(type) {
    cheeseType = type;
    return cheeseType;
}
 
cheddar = new Cheese("cheddar"); 
4.Вызов apply и call — Apply And Call Invocation
func.call(context, arg1, arg2…) – вызывает func с данным контекстом и аргументами.
func.apply(context, args) – вызывает func, передавая context как this и псевдомассив args как список аргументов.
В современном стандарте call/apply передают this «как есть». А в старом, без use strict, при указании первого аргумента null или undefined в call/apply, функция получает this = window, 

  * Как директива `use strict` влияет на `this` внутри функции? в строгом режиме значение this в функции не заменяется автоматически ссылкой на глобальный объект в том случае, если this устанавливается в значение, не являющееся объектом.

В нестрогом режиме значением this в таком случае будет глобальный объект (window для браузера, мы вернёмся к этому позже в главе Глобальный объект). Это – исторически сложившееся поведение this, которое исправляется использованием строгого режима ("use strict").

Обычно подобный вызов является ошибкой программирования. Если внутри функции используется this, тогда ожидается, что она будет вызываться в контексте какого-либо объекта.

* Какой наиболее простой паттерн, позволяющий облегчить читаемость функции, когда у нее огромное количество аргументов?
const menuConfig = {
  title: 'Foo',
  body: 'Bar',
  buttonText: 'Baz',
  cancellable: true
};

function createMenu(config) {
  // ...
}

createMenu(menuConfig);

* Как получить все аргументы функции (включая те, что не объявлены, но все-таки были переданы)?Объект arguments — это локальная переменная, доступная внутри любой (нестрелочной) функции,  подобный массиву объект, который содержит аргументы, переданные в функцию.
function func1(a, b, c) {
  console.log(arguments[0]);
  // expected output: 1

  console.log(arguments[1]);
  // expected output: 2

  console.log(arguments[2]);
  // expected output: 3
}

func1(1, 2, 3);

синтаксис оставшихся параметров
function myFun(a, b, ...manyMoreArgs) {
  console.log("a", a);
  console.log("b", b);
  console.log("manyMoreArgs", manyMoreArgs);
}

myFun("один", "два", "три", "четыре", "пять", "шесть");

// Console Output:
// a, один
// b, два
// manyMoreArgs, [три, четыре, пять, шесть]

* Что такое рекурсия? Когда удобно её использовать? 
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) );

В рекурсии фуекция вызывает саму себя и главное указать условие выхода из рекурсии, после всех итераций она начинает считать с конца. Считается, что рекурсия и циклы взаимозаменяемы, но рекурсия обычно кароче, а циклы мощнее.Вы берете линию один и говорите им «пожалуйста, держитесь». Затем вы берете линию два и ставите их на удержание. Затем вы поднимаете линию три и помещаете их в режим ожидания. Наконец, вы отвечаете на четвертую строку и говорите с вызывающим. Когда вы закончите с четвертым абонентом, вы повесите трубку и возьмете третий звонок. Когда вы закончите с третьим вызовом, вы повесите трубку и возьмете второй звонок. Когда вы закончите со вторым вызовом, вы повесите трубку и заберете первый звонок. Когда вы закончите этот звонок, вы можете, наконец, положить телефон.
function look_for_key(box) {
  for (item in box) {
    if (item.is_a_box()) {
      look_for_key(item);
    } else if (item.is_a_key()) {
      console.log("found the key!")
    }
  }
}

* Что такое замыкания, и в каких случаях они могут быть полезны? Как сохранить состояние с помощью замыкания, и для чего это состояние может быть использовано?
Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание дает вам доступ к Scope внешней функции из внутренней функции.Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В JavaScript замыкания создаются каждый раз при создании функции, во время ее создания.
Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, когда функция выполняется.

Вложенные функции
Функция называется «вложенной», когда она создаётся внутри другой функции.
funtion crIncr(n) {
  return function(num) {
  return n + num
   }
 }
 
 const addOne = crIncr(1)
 const addTen = crIncr(10)
 
 clg(addOne(10))  //11
 clg(addTen(41)) //51

И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.

* Решить такую вот проблему: пускай у нас есть массив ссылок, и наша задача — сделать так, чтобы при клике на каждую выводился `alert`ом ее порядковый номер. Первое решение, что приходит в голову, выглядит так:
  ```javascript
  for (var i = 0; i < links.length; i++) {
     links[i].onclick = function() {
        alert(i);
     }
  }
  ```
  На деле же оказывается, что при клике на любую ссылку выводится одно и то же число — значение `links.length`. Почему так происходит и как эту гадость исправить?
https://learn.javascript.ru/task/make-army + (let i = 0; i < links.length; i++)
Переменная var – одна на все итерации цикла и видна даже после цикла:
С переменной let – всё по-другому.
Каждому повторению цикла соответствует своя независимая переменная let. Если внутри цикла есть вложенные объявления функций, то в замыкании каждой будет та переменная, которая была при соответствующей итерации.

* Что такое callback (функция обратного вызова)? Когда они обычно применяются? фу́нкция обра́тного вы́зова в программировании — передача исполняемого кода в качестве одного из параметров другого кода.

* Что такое каррирование?
Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).
function curry(f) { // curry(f) выполняет каррирование
  return function(a) {
    return function(b) {
      return f(a, b);
    };
  };
}

* Что такое частичное применение?
Частичное применение - это просто естественная комбинация каррированных функций и замыканий. Ранее примененные аргументы сохраняются и доступны для возвращаемых новых функций. Этот процесс может существенно облегчить написание и понимание кода.
const multiply = (x, y) => x * y

const multiply2 = multiply.bind(null, 2)

console.log(multiply2(3)) // 6
console.log(multiply2(4)) // 8
console.log(multiply2(5)) // 10

* Что такое мемоизация?
Мемоизация — сохранение результатов выполнения функций для предотвращения повторных вычислений. Это один из способов оптимизации, применяемый для увеличения скорости выполнения компьютерных программ.

#### Ресурсы

* [Some Closure on Closures](https://dev.to/jckuhl/some-closure-on-closures-44ga)
* [What's so useful about closures (in JS)?](https://softwareengineering.stackexchange.com/questions/203507/whats-so-useful-about-closures-in-js)
* [Why would a program use a closure?](https://softwareengineering.stackexchange.com/questions/285941/why-would-a-program-use-a-closure)
* [Четыре паттерна вызова функций в JavaScript](https://habr.com/ru/post/155815/)
* [Каррирование функций в JavaScript](https://habr.com/ru/company/ruvds/blog/427295/)
* [Карринг и частичное применение](https://www.ibm.com/developerworks/ru/library/j-jn9/)
* [Мемоизация в JS и ускорение функций](https://habr.com/ru/company/ruvds/blog/332384/)

## Прототипы

* Что такое функция-конструктор? Как их создавать и как ими пользоваться? 
Функции-конструкторы или просто конструкторы являются обычными функциями, именовать которые следует с заглавной буквы.
Конструкторы следует вызывать при помощи оператора new. Такой вызов создаёт пустой this в начале выполнения и возвращает заполненный в конце.

* Что такое прототип? Какие возможности имеет/дает? [[Prototype]] и хранит в себе ссылку на объект от которого наследуется или равен null, объект на который ссылается называется "прототипом". __proto__ является геттером\сетером для [[Prototype]], да и вообще хранит в себе все "скрытые" свойтсва и методы.
Object.prototype.__proto__
Все объекты в JavaScript являются потомками Object; все объекты наследуют методы и свойства из прототипа объекта Object.prototype, хотя они и могут быть переопределены (за исключением объекта Object с прототипом null, то есть, созданным вызовом Object.create(null)). Например, прототипы других конструкторов переопределяют свойство constructor и предоставляют свои собственные методы toString(). Изменения в объекте прототипа Object распространяются на все объекты до тех пор, пока свойства и методы, учитывающие эти изменения, не переопределяются дальше по цепочке прототипов.

* Почему методы объекта лучше хранить в прототипе, а не в самом объекте? 
Например у вас есть 1000 объектов, у каждого объекта в конструкторе есть метод который делает одно и тоже для каждого объекта. Занимает память? думаю да. Можно в прототип вынести этот метод и метод будет всего один для каждого объекта, а к нему будут вести ссылки. С точки зрения оптимизации так будет лучше

* Можно ли создать инстанс функции через конструктор? new Function('a', 'b', 'return a + b');
new Function([arg1[, arg2[, ...argN]],] functionBody)

* Как создать объект, который ни от чего не наследуется? Object.create(null)

* Какие 3 (как минимум) способа есть отнаследоваться в JavaScript-е? В чем отличия и нюансы?
1.Шаблон конструктор - все методы определены в prototype, а свойства в конструкторе
2.Определение класса - объеденяет конструктор и методы
3.Явное объявление прототипа, Object.create,

* Как в переопределенном методе у наследующего класса вызвать переопределяемый метод родительского?
super() - родю конструктор
super.method() - род метод
  Пример псевдокода:
  ```javascript
  class Person
      method getFullName()
          return this.name + this.surname

  class Employee extends Person
      method getFullName()
          return super() + this.position
     ```     
            class Employee extends Person
      method getFullName()
          return super.getFullName() + this.position
  ```

#### Ресурсы

* [ES6 классы](http://jsraccoon.ru/es6-classes)
* [Классы в ECMAScript 6](https://frontender.info/es6-classes-final/)
